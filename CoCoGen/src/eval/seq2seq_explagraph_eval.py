# evaluates explagraph output generated by seq2seq models
import pathlib
import pandas as pd
import tempfile
import subprocess

"""{
    "source": "Generate an Explanation Graph for Belief: marriage is an outdated concept. Argument: kids need a happy environment to grow up. Stance: counter",
    "target": "(kids; desires; happy environment)(happy environment; causes; sense of security)(sense of security; is not a; outdated concept)(marriage; part of; happy environment)",
    "pred": "(kids; desires; happy environment)(kids; desires; happy environment)(happy environment; not part of; outdated concept)"
}
"""

def run(output_path: str, tag: str, src_field: str, ref_field: str, pred_field: str):
    data = pd.read_json(output_path, lines=True, orient="records")
    predictions = []
    references = []
    for i, row in data.iterrows():
        source = row[src_field]
        # extract Stance: XYZ from source
        stance = source.split("Stance: ")[1].strip()
        pred_graph = row[pred_field]
        belief = source.split("Belief: ")[1].strip().split(". ")[0] + ". "
        argument = source.split("Argument: ")[1].strip().split(". ")[0] + ". "
        ref_graph = row[ref_field]
        predictions.append({
            "stance": stance,
            "graph": pred_graph,
        })
        references.append({
            "stance": stance,
            "graph": ref_graph,
            "belief": belief,
            "argument": argument,
        })
    predictions = pd.DataFrame(predictions)
    references = pd.DataFrame(references)
    references = references[["belief", "argument", "stance", "graph"]]
    predictions = predictions[["stance", "graph"]]
    # write to a random temp file
    with tempfile.NamedTemporaryFile(mode="w", delete=False) as f_pred:
        predictions.to_csv(f_pred.name, index=False, header=False, sep="\t")
        print(predictions.head())
        print(f"Predictions temp file: {f_pred.name}")
    
    with tempfile.NamedTemporaryFile(mode="w", delete=False) as f_ref:
        references.to_csv(f_ref.name, index=False, header=False, sep="\t")
        print(references.head())
        print(f"References temp file: {f_ref.name}")
    
    output_path_dir = pathlib.Path(output_path).parent
    
    # output_path_dir = pathlib.Path(*output_path_dir.parts[2:])

    parts = ["bash", "data/ExplaGraphs/eval_scripts/run_all.sh", f_pred.name, f_ref.name, output_path_dir]
    print(f"Running: {' '.join(map(str, parts))}")
    subprocess.Popen(parts).wait()
    pprint_results(f"{output_path_dir}/report.txt")


    # renmae the output fiilie to include the tag
    new_path = pathlib.Path(output_path).parent / f"{tag}.txt"
    report_path = pathlib.Path(output_path).parent / f"report.txt"

    print(f"Renaming {output_path} to {new_path}")
    report_path.rename(new_path)
    


    

def pprint_results(path):
    idx = {
        "struct_accuracy": 0,
        "eval_SeCA": 1,
        "g_bert_f1": 2,
        "ged": 3,
        "Edge Importance Accuracy (EA)": 4
    }
    scores = [0 for _ in range(len(idx))]
    with open(path) as f:
        for line in f:
            metric, value = line.strip().split("=")
            metric = metric.strip()
            if metric in idx:
                if idx != "ged":
                    scores[idx[metric]] = round(float(value) * 100, 2)
                else:
                    scores[idx[metric]] = round(float(value), 2)

    print(", ".join(map(str, scores)))

if __name__ == '__main__':
    import argparse
    parser = argparse.ArgumentParser()
    parser.add_argument("--outputs", type=str, required=True)
    parser.add_argument("--tag", type=str, required=True)
    parser.add_argument("--src", type=str, default="source")
    parser.add_argument("--ref", type=str, default="target")
    parser.add_argument("--pred", type=str, default="pred")
    args = parser.parse_args()
    run(output_path=args.outputs, tag=args.tag, src_field=args.src, ref_field=args.ref, pred_field=args.pred)
